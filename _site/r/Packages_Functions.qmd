---
title: "R class - packages and functions"
fontsize: 1.5em
linkcolor: grey
callout-appearance: simple
format: 
  revealjs:
    transition: none
    theme: beige
    scrollable: true
author: "Karen Cristine Goncalves, Ph.D."
date: "August 2023"
incremental: false
echo: true
message: false
warning: false
slide-number: true
---

```{r, include=F}
options(repos="https://cran.rstudio.com/")
```


## Be lazy!

The most certain way to make mistakes when programming is typing everything.

Think of when you are writing a text, how many typos do you make? This will happen when you are coding!

Realizing there are typos or bigger mistakes in your code is more difficult than in a text to a friend. 

So, be lazy and copy/paste codes when possible. 

. . .

Also, don't try to re-invent the wheel. Check on [stack-overflow](https://stackoverflow.com/questions/tagged/r), [bioconductor](https://support.bioconductor.org/) or [github](github.com) to see if other people already tried what you are doing and the solutions they came up with. You can always edit their code!

## Packages 

These are simply folders containing files with many functions.

They may contain data so you can test the functions.

### How to use packages

:::{.panel-tabset}

# Install

If you never used the package, it probably is not installed in your computer, so you need to use the function "install.packages"

```{.codeblock}
install.packages("rmarkdown") # a package with functions for multivariate stats functions

# You can install many packages at once
install.packages(c("venn", "tidyverse"))
```


# Load

This just installs the package, but it is not loaded yet (opened in R). To load, use the function library

```{r}
library(rmarkdown)
library("tidyverse") # you do not need the quotes with the function library
```

:::{.callout-caution}
You cannot put multiple package names in the library function
You need to load them one by one
:::

# Advanced install and load

Come back to this part once you are more comfortable with programming.

You cannot put a vector (ie. `c("a", "b", "c")`) inside `library()`, but you can write a code that loads the packages one by one without you writing that manually.

```{r}
# start by creating a vector with all the packages you need
pkgs = c("rmarkdown", "tidyverse", "venn")

# We check which packages are NOT (!) installed
pkgs.To.Install = ! pkgs %in% installed.packages()

# any() checks if there is at least one TRUE in the vector
if (any(pkgs.To.Install)) install.packages(pkgs[pkgs.To.Install])

map(pkgs, \(pkg) library(pkg, character.only = T))
```

:::


## Tidyverse - many packages that make your life easier 

When you load the package "tidyverse", it tells you that it loaded many others (packages from the uni*verse* **tidy**)

1. Tables and data.frames
	- dplyr: many functions to work with tables
	- tibble: construct data frames (tables)
	- tidyr: tools to better organize data (make it `tidy`ier)
	- readr: fast and friendly functions to read table data
2. Text-like data
	- forcats: (anagram of `factors`) tools to work with factors ([tutorial](https://cran.r-project.org/web/packages/forcats/vignettes/forcats.html))
	- stringr: work with text (character variables)
	- lubridate: work with dates

3. Plots
	- ggplot2: create better plots
4. Programming
	- purrr: functional programming in R ([cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/purrr.pdf))

## Pipe

Let's say you just want to check if R will read your file right or if you need to add more things to it before really working on the file.

:::{.panel-tabset}

# Exercise

Run the function `str` on your input file or on the <a style="color: red" href="https://karengoncalves.github.io/Programming_classes/r/exampleData/Class1_exampleData.txt">example from Class 0</a>

# Solution 1
```{r}
# The normal way to do what we want would be this, but it is difficult to read
str(read.delim("https://karengoncalves.github.io/Programming_classes/r/exampleData/Class1_exampleData.txt"))
```

# Solution 2
```{r}
# You could first put the path to the file in a variable, it would make things easier
myFile = "https://karengoncalves.github.io/Programming_classes/r/exampleData/Class1_exampleData.txt"

str(read.delim(myFile))

```

# Solution 3

```{r}
# You can also use a pipe ( %>% ) : moves the output of a function to the input of another
myFile = "https://karengoncalves.github.io/Programming_classes/r/exampleData/Class1_exampleData.txt"

read.delim(myFile) %>% str
```
:::

:::{.callout-tip}
You can load files from the internet without needing to download them to your computer!
:::

## ggplot2


:::{.panel-tabset}

# Exercise

Create a colored boxplot with the dataset iris, with nice axes titles

# Solution 1

Code from the previous class
```{r first graph - colored-formatted boxplot}
colors = c("red", "green", "blue")
boxplot(Sepal.Length ~ Species, 
	data = iris, col = colors, 
	ylab = "Sepal length (mm)", xlab = "Species epithet")
```

# Solution 2

Use ggplot. The syntax may take a while to get used to, but it is easier to read.

```{r}
# aes is short for aesthetics, basically what columns hold the values you want to plot
# fill is the color that will be inside the box, color is just for the border
ggplot(data = iris,
       aes(x = Species,
           y = Sepal.Length,
           fill = Species)) +
	geom_boxplot() + # the type of plot you want
	ylab("Sepal length (mm)") +
	xlab("Species epithet")
```

# Solution 3

Improve ggplot by setting a better theme [(check here see the options)](https://ggplot2.tidyverse.org/reference/ggtheme.html)

```{r}
# Set a theme for all future plots in this session
theme_set(theme_bw()) 

# Use different colors to fill and remove the legend
colors = c("red", "green", "blue")

ggplot(data = iris,
       aes(x = Species,
           y = Sepal.Length,
           fill = Species)) +
	geom_boxplot(show.legend = F) + # the type of plot you want
	ylab("Sepal length (mm)") +
	xlab("Species epithet") +
	scale_fill_manual(values = colors)
```

:::

## dplyr: prepare your data for ggplot

In the example dataset, the names of the groups are in the middle not specified, they are inside the replicate name. We need one column with the values and one with the names of the treatments.

```{r}
myFile = "https://karengoncalves.github.io/Programming_classes/r/exampleData/Class1_exampleData.txt"

rawData = read.delim(myFile)
names(rawData)

# Let's change x to "Measured"
names(rawData)[1] = "Measured"
```

:::{.panel-tabset}

# Pivot-longer

The table now is in the format "wide", the one we want is called "long"

```{r}

longData = pivot_longer(
	data = rawData,
	cols = !Measured, # gets all the columns of the table, except for the one in front of !
	names_to = "Replicates", # name of the column that will contain column names from rawData
	values_to = "Measurements"
	)

str(longData)
```

# New column

Let's split the values from "Replicates" using str_split from stringr

```{r}
# pattern is what separates (_)
# i is the part that we want to see: Control_1 has 2 pieces, i=1 returns "Control"

longDataTreaments = mutate(
	.data = longData,
	Treatment = str_split_i(Replicates, pattern = "_", i = 1)
)

str(longDataTreaments)
```
# Plot

Let's plot

```{r}
longDataTreaments %>%
	ggplot(aes(x = Treatment,
		   y = Measurements,
		   fill = Measured, color = Measured)) +
	geom_point()

longDataTreaments %>%
	ggplot(aes(x = Measured,
		   y = Measurements,
		   fill = Treatment, color = Treatment)) +
	geom_point()
```

:::

## Stats 

Visually, it seems that the control is much more varied than the treated samples, how can we check that?

:::{.panel-tabset .incremental}

# Problem

We need to:

1. Get the values for each data measured
2. Separate them by treatment 
3. Calculate the standard deviation for each group

# Step 1

Create variables to hold what you will need

```{r}
# This table will have just the treatments and their replicates
repsTreatments = 
	longDataTreaments[, c("Replicates", "Treatment")] %>%
	unique
	
measuredData = rawData$Measured 
```

# Step 2

::: {.panel-tabset }

# Option 1

Instead of calculating everything one by one and repeating the same code, we can use the function "sapply"

:::{.callout-note}
x is a variable that ONLY EXISTS inside the sapply below

%in% is a function that checks which elements of the first vector are in the second one
:::

```{r}
ControlSD = sapply(measuredData, function(x) { # we need this because we will use several lines of code
	
	currentRow = rawData$Measured == x 
	# == means "equal to", the result is a vector of the same size as the first with TRUE/FALSE values
	
	controlCols = filter(repsTreatments,
			     Treatment == "Control"
	)
	
	sd(rawData[currentRow, controlCols$Replicates])
	
})

TreatedSD = sapply(measuredData, function(x) { # we need this because we will use several lines of code
	
	currentRow = rawData$Measured == x 
	TreatedCols = filter(repsTreatments,
			     Treatment == "Treated"
	)
	sd(rawData[currentRow, TreatedCols$Replicates])
	
})
```

# Option 2

We can use lapply to remove repetition, use the same code to calulate the SD for the control and the treatment


```{r}
sdList = lapply(unique(repsTreatments$Treatment), function(group) {
	currentGroupColumns = 
		filter(repsTreatments,
		       Treatment == group
		)
	
	sapply(measuredData, function(x) {
	currentRow = rawData$Measured == x
	sd(rawData[currentRow, currentGroupColumns$Replicates])
	})
})
names(sdList) = unique(repsTreatments$Treatment)


```
:::

# Step 3

Make a table with the results

```{r}
# If you used Step 2 - option 1
(sdDataFrame = data.frame(Control = ControlSD,
			 Treated = TreatedSD))

# If you used option 2
(sdDataFrame = do.call(what = "cbind", # bind the columns
	sdList) %>% as.data.frame)
```

:::{.callout-note}
The result of lapply is a list, so we use `do.call(what = "cbind")` to join the two lists into one matrix, then we transform the matrix into a data.frame
:::

# Step 4

1. Run a paired T test (value A of column 1 has to be compared to value A of column 2)
2. Make a bar graph (geom_col with ggplot2)

```{r}

t.test(x = sdDataFrame$Control, y = sdDataFrame$Treated, 
       paired = T)

pivot_longer(data = sdDataFrame,
	     cols = everything(),
	     values_to = "Standard.deviation",
	     names_to = "Treatment") %>%
	ggplot(aes(x = Treatment, y = Standard.deviation)) +
	geom_col(fill = "black")

```
:::

## Types of plots

1. [Boxplot]()