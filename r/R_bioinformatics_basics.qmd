---
title: "R for bioinformatics - basics"
author: "Karen C. Goncalves, Ph.D."
fontsize: 1.25em
linkcolor: grey
callout-appearance: simple
format: 
  revealjs:
    transition: none
    theme: dark
    scrollable: true
date: "January 2024"
incremental: false
echo: true
warning: false
eval: true
---

## Packages

Before, we installed packages with the code below

```{.r}
pkgs = c("rmarkdown", "tidyverse", "venn")
pkgs.To.Install = which(! pkgs %in% installed.packages())
if (length(pkgs.To.Install) != 0) install.packages(pkgs[pkgs.To.Install])
for (curPkg in pkgs) library(curPkg, character.only = T) 
```

However, most packages for bioinformatics are not downloadable with a simple `install.packages`, as they are not stored in [CRAN](https://cran.r-project.org/), the basic website for R packages.

Instead, they are in [Bioconductor](https://www.bioconductor.org/), and some are in specific github repositories (think about the [R_class_examples](https://github.com/KarenGoncalves/R_class_examples)).

## Installing packages from other sources

:::{.panel-tabset collapse="true"}

# Bioconductor packages

For these, we use the package BiocManager.

```{.r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
pkgs.bioconductor = c("msa", "Biostrings")
pkgs.To.Install = which(! pkgs.bioconductor %in% installed.packages())
if (length(pkgs.To.Install) != 0) {
	BiocManager::install(pkgs.bioconductor[pkgs.To.Install])	
}
```

:::{.callout-tip}
In `BiocManager::install`, the `::` indicates that the function `install` comes from the package `BiocManager`.

So even if there is another package with the same function, R will know which one to use.
:::

# Github packages

:::{.callout-tip}

Github is a website that has folders for each user, and each user may have multiple folders: one for each project. Example, in:

- https://github.com/KarenGoncalves/R_class_examples
	- `KarenGoncalves/` is my folder in the website, in there I have over 20 folders, one for each project.
	- R_class_examples is one of them.
:::

```{.r}
if (! "devtools" %in% installed.packages()) {
	install.packages("devtools")
}

repos.github = c("YuLab-SMU/ggmsa")
pkgs.github = gsub(".+/", "", repos.github) # remove the folder name
pkgs.To.Install = which(! pkgs.github %in% installed.packages())

if (length(pkgs.To.Install) != 0) {
	# To install the package, we need the folder + package name
	devtools::install_github(repos.github[pkgs.To.Install])	
}
```

:::

## Simplified install

Copy the code below to load all the necessary packages. 

In future, just come back here, copy the code below and change the list of packages.

```{r}
#| output: false
#| warning: false

devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")

install_from_dif_sources(
	cran_packages = c("tidyverse", "tinytex", "patchwork"),
	bioconductor_packages = c("Biostrings", "msa", "treeio", "ggtree", "ape", "seqinr", "phangorn"),
	github_packages = "YuLab-SMU/ggmsa"
)
```


:::{.callout-tip}
The link [https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978](https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978) contains the R script that creates functions to load the packages from different sources: CRAN (the typical source), Bioconductor and github.

So you just need to give the link to the function `devtools::source_gist()` and then you can use the function `install_from_dif_sources`
:::

## Reading and writing fasta files

If you have protein sequences in a fasta file, copy it to your `inputs` folder, else use the following:  [Reductases.fasta](./exampleData/Reductases.fasta)

```{r}
# To open a fasta file with multiple sequences, use the function readDNAStringSet() or readAAStringSet()
fasta_input = "https://karengoncalves.github.io/Programming_classes/r/exampleData/Reductases.fasta" %>%
	readAAStringSet(format = "fasta")
head(fasta_input)

# If you want to select just one or two sequences and export it, you can do:
writeXStringSet(fasta_input[1:3], 
		filepath = "input_subset.fasta", 
		format = "fasta")
```

## Multiple Sequence Alignment (MSA)

Make things easy for yourself later, add the names of the parameters of each function so you know what you need to put next time.

- There are 4 functions for MSA:
	- `msaClustalW` - ClustalW is a general purpose multiple alignment program for DNA or proteins. [<sup>1</sup>](http://www.clustal.org/download/clustalw_help.txt)
		- `cluster` parameter can be either Neighbor Joining (`"nj"`) or Unweighted Pair Group Method with Arithmetic mean (`"upgma"`)
			- Do not use `"upgma"` if you are on windows and your R version is 4.x (x being any number) - R crashes
	- `msaClustalOmega` - New MSA tool that uses seeded guide trees and HMM profile-profile techniques to generate alignments. Suitable for medium-large alignments.[<sup>2</sup>](https://www.ebi.ac.uk/Tools/msa/)
		- default `substitutionMatrix`: `"Gonnet"`; other options: `"BLOSUM30"`, `"BLOSUM40`, `"BLOSUM50"`, `"BLOSUM65"` and `"BLOSUM80"`.
	- `msaMuscle` - Accurate MSA tool, especially good with proteins. Suitable for medium alignments.[<sup>2</sup>](https://www.ebi.ac.uk/Tools/msa/)
		- `cluster` parameter can be either NJ (`"neighborjoining"`) or UPGMA (`"upgma"`) - UPGMA gives better results [<sup>3</sup>](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC517706/)
	- `msa` - you can set the method with the argument `method` or just put the sequences and use the default (`"Clustalw"`) (other options: `"ClustalOmega"`, `"Muscle"`)

- Add `verbose = T` so that the parameters used are printed to the screen and you can take not for your publications.

## Running MSA

```{r}
# The dataset used as example has 48 sequences, we will subset it for the alignment, selecting only 10
fasta_for_alignment <- fasta_input[1:10]
# use ?msa to know what you need to put in the function and what the default values are
myFirstAlignment <- msa(fasta_for_alignment, 
			method = "ClustalOmega",
			verbose = T
)

myFirstAlignment
```

:::{.callout-note}

# Visualizing the result

Just calling the MSA result will not show the whole alignment. For that you can use `print()`

```{.r}
print(myFirstAlignment, show = "complete", showConsensus = T)
```
:::

## Use ggmsa for visualization

To see the alignment as a plot, we can use `ggmsa`.

:::{.callout-note}

We need to change the type of object of the alignment result, as `ggmsa` only accepts `"AAMultipleAlignment"` objects

:::

```{r}
# The original result is of class MsaAAMultipleAlignment
myFirstAlignment2 <- myFirstAlignment # keep the original, make a copy to modify it
class(myFirstAlignment2) <-  "AAMultipleAlignment"

# We will plot only a part of the alignment - from the AA 220 to the AA 250 - so it is visible 
ggmsa(myFirstAlignment2, 
      start = 220, end = 250, 
      seq_name = T)

# We can see also the consensus highlighted
ggmsa(myFirstAlignment2, 
      start = 220, end = 250, 
      seq_name = T, consensus_views = T)

# Remove the # below if you want to save the figure
#ggsave("First_alignment_consensus_220_250.tiff")
```

## More `ggmsa` options

:::{.panel-tabset}

# Residue size

We can set the width of the characters (use `char_width = #`), so the residues are not so big

```{r}
ggmsa(myFirstAlignment2, 
      start = 220, end = 250, 
      seq_name = T, char_width = 0.5)

```

# SeqLogo

A seqlogo is a plot with letters on top of each other representing their frequency at each position in the alignment. The bigger a letter, the more frequent it is at a given position. 

- We can add this plot with `+ geom_seqlogo()`
	- you can use different color schemes with `geom_seqlogo(color = #)`<sup>1</sup>
	- you can set your color scheme with `geom_seqlogo(custom_color = data.frame)`<sup>1</sup>
	
```{r}
ggmsa(myFirstAlignment2, 
      start = 220, end = 250, 
      seq_name = T, char_width = 0.5) + 
	geom_seqlogo() 
# Note that the gaps are also represented in the seqlogo!

```

:::{.callout-tip}
<sup>1</sup> Check the options with `?geom_seqlogo`
:::

# Consensus as bar graph

```{r}
ggmsa(myFirstAlignment2, 
      start = 220, end = 250, 
      seq_name = T, char_width = 0.5) + 
	geom_seqlogo() +
	geom_msaBar()
```

:::

## Make a phylogenetic tree

**Learn what is necessary to make a tree, how to read it and what conclusions you can and cannot draw from them.**

- Sequences used for the tree are the leaves/tips.
- The point where the tree starts (the center if it is circular, or the first tip to separate from the rest of the tree) is the root
- The lines drawing the tree are the branches/edges.
- Going from the leaves to the root, the point where two branches connect is called a node


## Compute the distance matrix

We will use `ape` and `seqinr` to create a tree from the alignment. But we need to, again, transform the type of object we got from the `msa`.

Then we calculate a distance matrix.

:::{.callout-tip}
A distance matrix shows how different each sequence is from the others. It has as many rows as columns, since every sequence is compared to the others. 

Its diagonal is all `0`s, since the difference between a sequence and itself is `0`.
:::

```{r}
myFirstAlignment3 <- 
	msaConvert(x = myFirstAlignment,
		   type = "seqinr::alignment")

# Then, we create a distance matrix
distance_alignment <- 
	dist.alignment(x = myFirstAlignment3)
```


## Tree computation

Then, we use the distance matrix to compute the tree, joining sequences most similar, then joining groups of sequences. Each method of computing will do this joining differently.

:::{.panel-tabset}

# nj

This function performs the neighbor-joining tree estimation of [Saitou and Nei (1987)](https://academic.oup.com/mbe/article/4/4/406/1029664?login=false).


```{r}
nj(X = distance_alignment) %>% plot(main = "ape::nj()")

nj(X = distance_alignment) %>% 
	plot(main = "phangorn::NJ()")
```

# bionj

This function performs the BIONJ algorithm of [Gascuel (1997)](https://academic.oup.com/mbe/article/14/7/685/1119804?login=false).

```{r}
bionj(X = distance_alignment) %>% plot(main = "ape::bionj")
UNJ(distance_alignment) %>% plot(main = "phangorn::UNJ")
```

# fastme

The two FastME (fast minimum evolution) functions (balanced - bal - and ordinary least-squares - ols) perform the minimum evolution algorithm of [Desper and Gascuel (2002)](https://www.liebertpub.com/doi/10.1089/106652702761034136).

```{r}
fastme.bal(distance_alignment) %>% plot(main = "FastME BAL")

fastme.ols(distance_alignment) %>% plot(main = "FastME OLS")
```

# UPGMA/WPGMA

- UPGMA: uses the function `hclust` (hierarchical clustering) with `method = "average"`, then transforms the dendrogram into the class `phylo`. 
- WPGMA:  uses the function `hclust` with `method = "mcquitty"`, then transforms the dendrogram into the class `phylo`. 

Run `?hclust` then look the section "Details": the methods are explained with more details with references.

```{r}
upgma(distance_alignment) %>% plot(main = "UPGMA")

wpgma(distance_alignment) %>% plot(main = "WPGMA")
```

:::

## Customizing the plot

We can use dplyr to separate protein and species names.

:::{.panel-tabset}

# Get the tree

```{r}
upgma_tree <- upgma(distance_alignment)
# We save the tree in a object so we can access the leaf labes with $tip.label
```

# Prepare the labels 

We will use a function called `parse` to italicize only the species name. It evaluates the text and executes functions inside it! Example, in:

`"'TYDC '~italic('Narcissus pseudonarcissus')"`

The texts `'TYDC '` and `'Narcissus pseudonarcissus'` (in italic) are joined by the symbol `~`.

In this case, the protein name has just letters and numbers and is at the start of the sequence name, followed by the species name. So we can use `gsub` to create the label we want.

```{r}
Seqnames_tree <- 
	gsub("(\\w+) (.+)", 
	     "'\\1 '~italic('\\2')",
	     upgma_tree$tip.label)
upgma_tree$tip.label <- Seqnames_tree
```

:::{.callout-note}
Check the result before plotting. See that your result looks like the example with `TYDC` above, as you need to use both double and single quotes.
:::

# Plot the labels

```{r}
ggtree(upgma_tree) +
	# use geom_tiplab to plot the seqnames
	# add parse = T so R executes the function inside the text
	geom_tiplab(parse = T) +
	xlim(c(0, 0.7)) 
	# the upper x limit may change depending on the length of your labels, play around until you get the whole label but little empty space
```

:::

## More customization

Let's say you want to add bars marking different groups in a tree, like the vertical bars marking the clades in the figure below [(Figure 3 in Hori et al. 2006)](https://doi.org/10.1266/GGS.81.243):

![](https://d3i71xaburhd42.cloudfront.net/82a7b788497724f0aee9b8b3ff45650c3489edfb/5-Figure3-1.png){width=40%}

## Highlight important nodes

:::{.panel-tabset}

# Identify the nodes

Just as we added the names of the leaves, we can add the names of the nodes with `geom_text(aes(label=node))`

We may need to play around with the `hjust`, which goes after `aes()`, inside `geom_text()`

```{r}
ggtree(upgma_tree) +
	geom_text(aes(label = node), hjust = -.2) +
	geom_tiplab(parse = T, hjust = -.15) +
	xlim(c(0, 0.8))
```

# Mark groups

In our example tree, there are 2 main groups: nodes 12 and 13. We can use the function`geom_cladelabel` to mark each one

:::{.callout-note}
There is also `geom_cladelab`, but you cannot change the color of the text with it
:::

```{r}
ggtree(upgma_tree) +
	# we do not need the line below anymore
	#geom_text(aes(label = node), hjust = -.2) +
	geom_tiplab(parse = T) +
	geom_cladelabel(node = 12, label = "Node 12",
			color = "red", offset = .35) +
	geom_cladelabel(node = 13, label = "Node 13",
			color = "green4", offset = .35,
			barsize = 2) +
	xlim(c(0, .9))

```

# Highlight groups

You can draw a rectangle around the node and its branches using `geom_highlight`

```{r}
ggtree(upgma_tree) +
	# we do not need the line below anymore
	#geom_text(aes(label = node), hjust = -.2) +
	geom_tiplab(parse = T) +
	geom_highlight(node = 12,
		       fill = "red") +
	# change the transparency of the rectangle with alpha
	geom_cladelabel(node = 13, label = "Node 13",
			color = "green4", offset = .35,
			barsize = 2) +
	xlim(c(0, .9))
```

:::

## Resources

- [Multiple sequence alignment in R - msa](https://www.bioconductor.org/packages/release/bioc/vignettes/msa/inst/doc/msa.pdf)
- [ape: phylogenetic trees](https://cran.r-project.org/web/packages/ape/vignettes/DrawingPhylogenies.pdf)
- [ggmsa](https://yulab-smu.top/ggmsa/)
- [ggtree](https://bioconnector.github.io/workshops/r-ggtree.html)
- [phangorn](https://cran.r-project.org/web/packages/phangorn/vignettes/Trees.html)


## About figures

As discussed in the lab meeting, graphs should be at 1200 dpi and either 8 or 17 cm wide. We can create functions that set these as default!

With this, we can now use these functions to save our plots, instead of using ggsave.

```{r my_ggsave}
# The function below is simply ggsave with 2 differences
my_ggsave <- function(plot = last_plot(),
		      dpi = 1200, 
		      columns = NA, ## NEED TO SET
		      device = NULL, 
		      path = NULL, 
		      scale = 1,  
		      height = NA, 
		      units = c("in", "cm", "mm", "px"),
		      limitsize = TRUE, 
		      bg = NULL) {
	# by setting dpi = 1200, we specify that, if not changed, dpi will be 1200
	# columns will be either 1 or 2. So if we want a figure to take one column, the width will be 8; if the figure takes 2 columns, the width will be 17
	if (!is.numeric(columns)) {
		stop("'columns' must be numeric!")
	} 
	width = ifelse(columns == 1, 8, 17)
	ggsave(plot = plot, 
	       filename = filename,
	       width = width,
	       dpi = dpi
	       )
}
```