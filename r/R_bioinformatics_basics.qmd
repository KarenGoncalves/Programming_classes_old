---
title: "R for bioinformatics - basics"
author: "Karen C. Goncalves, Ph.D."
fontsize: 1.25em
linkcolor: grey
callout-appearance: simple
format: 
  revealjs:
    transition: none
    theme: dark
    scrollable: true
date: "January 2024"
incremental: false
echo: true
warning: false
eval: true
---

## Packages

Before, we installed packages with the code below

```{.r}
pkgs = c("rmarkdown", "tidyverse", "venn")
pkgs.To.Install = which(! pkgs %in% installed.packages())
if (length(pkgs.To.Install) != 0) install.packages(pkgs[pkgs.To.Install])
for (curPkg in pkgs) library(curPkg, character.only = T) 
```

However, most packages for bioinformatics are not downloadable with a simple `install.packages`, as they are not stored in [CRAN](https://cran.r-project.org/), the basic website for R packages.

Instead, they are in [Bioconductor](https://www.bioconductor.org/), and some are in specific github repositories (think about the [R_class_examples](https://github.com/KarenGoncalves/R_class_examples)).

## Installing packages from other sources

:::{.panel-tabset collapse="true"}

# Bioconductor packages

For these, we use the package BiocManager.

```{.r}
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
pkgs.bioconductor = c("msa", "Biostrings")
pkgs.To.Install = which(! pkgs.bioconductor %in% installed.packages())
if (length(pkgs.To.Install) != 0) {
	BiocManager::install(pkgs.bioconductor[pkgs.To.Install])	
}
```

:::{.callout-tip}
In `BiocManager::install`, the `::` indicates that the function "install" comes from the package "BiocManager".

So even if there is another package with the same function, R will know which one to use.
:::

# Github packages

:::{.callout-tip}

Github is a website that has folders for each user, and each user may have multiple folders: one for each project. Example, in:

- https://github.com/KarenGoncalves/R_class_examples
	- `KarenGoncalves/` is my folder in the website, in there I have over 20 folders, one for each project.
	- R_class_examples is one of them.
:::

```{.r}
if (! "devtools" %in% installed.packages()) {
	install.packages("devtools")
}

repos.github = c("YuLab-SMU/ggmsa")
pkgs.github = gsub(".+/", "", repos.github) # remove the folder name
pkgs.To.Install = which(! pkgs.github %in% installed.packages())

if (length(pkgs.To.Install) != 0) {
	# To install the package, we need the folder + package name
	devtools::install_github(repos.github[pkgs.To.Install])	
}
```

:::

## Simplified install

Copy the code below to load all the necessary packages. 

In future, just come back here, copy the code below and change the list of packages.

```{r}
#| output: false

devtools::source_gist("https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978")

install_from_dif_sources(
	cran_packages = c("tidyverse", "tinytex"),
	bioconductor_packages = c("Biostrings", "msa", "treeio", "ggtree"),
	github_packages = "YuLab-SMU/ggmsa"
)
```


:::{.callout-tip}
The link [https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978](https://gist.github.com/KarenGoncalves/0db105bceff4ff69547ee25460dda978) contains the R script that creates functions to load the packages from different sources: CRAN (the typical source), Bioconductor and github.

So you just need to give the link to the function `devtools::source_gist()` and then you can use the function `install_from_dif_sources`
:::

## Reading and writing fasta files

Put in your script the codes from the two previous slides, as we will use the packages "tidyverse", "Biostrings", "msa" and "ggmsa".


If you have protein sequences in a  fasta file, copy it to your `inputs` folder, else use the following:  [reductases.fasta](./exampleData/Reductases.fasta)

```{r}
# To open a fasta file with multiple sequences, use the function readDNAStringSet() or readAAStringSet()
fasta_input = "https://karengoncalves.github.io/Programming_classes/r/exampleData/Reductases.fasta" %>%
	readAAStringSet(format = "fasta")
head(fasta_input)

# If you want to select just one or two sequences and export it, you can do:
writeXStringSet(fasta_input[1:3], 
		filepath = "input_subset.fasta", 
		format = "fasta")
```

## Multiple Sequence Alignment (MSA)

Make things easy for yourself later, add the names of the parameters of each function so you know what you need to put next time.

- There are 4 functions for MSA:
	- `msaClustalW` - ClustalW is a general purpose multiple alignment program for DNA or proteins. [<sup>1</sup>](http://www.clustal.org/download/clustalw_help.txt)
		- `cluster` parameter can be either Neighbor Joining (`"nj"`) or Unweighted Pair Group Method with Arithmetic mean (`"upgma"`)
			- Do not use `"upgma"` if you are on windows and your R version is 4.x (x being any number) - R crashes
	- `msaClustalOmega` - New MSA tool that uses seeded guide trees and HMM profile-profile techniques to generate alignments. Suitable for medium-large alignments.[<sup>2</sup>](https://www.ebi.ac.uk/Tools/msa/)
		- default `substitutionMatrix`: `"Gonnet"`; other options: `"BLOSUM30"`, `"BLOSUM40`, `"BLOSUM50"`, `"BLOSUM65"` and `"BLOSUM80"`.
	- `msaMuscle` - Accurate MSA tool, especially good with proteins. Suitable for medium alignments.[<sup>2</sup>](https://www.ebi.ac.uk/Tools/msa/)
		- `cluster` parameter can be either NJ (`"neighborjoining"`) or UPGMA (`"upgma"`) - UPGMA gives better results [<sup>3</sup>](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC517706/)
	- `msa` - you can set the method with the argument `method` or just put the sequences and use the default (`"Clustalw"`) (other options: `"ClustalOmega"`, `"Muscle"`)

- Add `verbose = T` so that the parameters used are printed to the screen and you can take not for your publications.

## Running MSA

```{r}
# The dataset used as example has 48 sequences, we will subset it for the alignment, selecting only 10
fasta_for_alignment <- fasta_input[1:10]
# use ?msa to know what you need to put in the function and what the default values are
myFirstAlignment <- msa(fasta_for_alignment, 
			method = "ClustalOmega",
			verbose = T
)

myFirstAlignment
```

:::{.callout-note}

# Visualizing the result

Just calling the MSA result will not show the whole alignment. For that you can use `print()`

```{.r}
print(myFirstAlignment, show = "complete", showConsensus = T)
```
:::

## Use ggmsa for visualization

To see the alignment as a plot, we can use `ggmsa`.

However, we need to change the type of object of the alignment result, as ggmsa only accepts "AAMultipleAlignment" objects

```{r}
# The original result is of class MsaAAMultipleAlignment
myFirstAlignment2 <- myFirstAlignment
class(myFirstAlignment2) <-  "AAMultipleAlignment"

# We will plot only a part of the alignment - from the AA 220 to the AA 250 - so it is visible 
ggmsa(myFirstAlignment2, 
      start = 220, end = 250, 
      seq_name = T)

# We can see also the consensus highlighted
ggmsa(myFirstAlignment2, 
      start = 220, end = 250, 
      seq_name = T, consensus_views = T)
#ggsave("First_alignment_consensus_220_250.tiff")
```

